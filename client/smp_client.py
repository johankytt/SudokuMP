'''
Created on 9. nov 2017

@author: Johan
'''
from common.smp_network import DEFAULT_HOST, DEFAULT_PORT
from client.smp_client_net import SMPClientNet
from common.smp_common import LOG, SMPException
from client.smp_client_gui import SMPClientGui
from common.smp_game_state import SMPGameState
import threading
import socket
from common.smp_server_discovery import SMPDiscoverySender
from PySide.QtCore import Signal, QObject


class SMPClient(QObject):
	'''
	classdocs
	'''

	_cid = 0  # Unique client id generated by server. 0 indicates unassigned or invalid.
	_cname = ''  # Player name
	_client_net = None
	_game_state = None  # State of the joined game

	serverDiscoveryRunningSignal = Signal(bool)
	serverDiscoveryFoundSignal = Signal(str, int)

	def __init__(self):
		super(SMPClient, self).__init__()
		self._game_lock = threading.Lock()
		self._serverDiscovery = None
		self._serverFound = False
		self.serverDiscoveryRunningSignal.connect(self.notifyServerDiscoveryRunning)
		self.serverDiscoveryFoundSignal.connect(self.notifyServerDiscoveryFound)
		self._gui = SMPClientGui(self)
		self._gui.show_lobby()

	##### SERVER DISCOVERY #####

	def startStopServerDiscovery(self):
		if self._serverDiscovery and self._serverDiscovery.isRunning():
			LOG.debug('SMPClient: Stopping server discovery')
			self._serverDiscovery.stop()
			self._serverDiscovery.wait()
			self._serverDiscovery = None
		else:
			LOG.debug('SMPClient: Starting server discovery')
			myaddr = socket.gethostbyname(socket.gethostname())
			self._serverDiscovery = SMPDiscoverySender((myaddr, 0), self)
			self._serverDiscovery.start()

	def stopServerDiscovery(self):
		''' Convenience function for quitting the application '''
		if self._serverDiscovery and self._serverDiscovery.isRunning():
			self.startStopServerDiscovery()

	def notifyServerDiscoveryRunning(self, isrunning):
		''' Notification from the SMPDiscoverySender instance '''
		if isrunning:
			LOG.debug('SMPClient: server discovery running')
			self._serverFound = False
		else:
			LOG.debug('SMPClient: server discovery not running')
			self._serverDiscovery = None

		if not self._serverFound:  # Server found signal does a different gui update
			self._gui.serverDiscoveryRunningSignal.emit(isrunning)

	def notifyServerDiscoveryFound(self, addr, port):
		''' Notification from the SMPDiscoverySender instance '''
		LOG.debug('SMPClient: server found')
		self._serverFound = True
		self._gui.serverDiscoveryFoundSignal.emit(addr, port)

	##### NETWORK CONNECTION #####

	def connectServer(self, addr=DEFAULT_HOST, port=DEFAULT_PORT, cname=''):
		''' Creates a SMPClientNet object and connects to the server '''

		LOG.info('SMPClient: connecting to {} with name {}.'.format((addr, port), cname))
		self.set_cname(cname)
		if len(self._cname) == 0:
			LOG.warn('Connecting with no player name set')

		self._client_net = SMPClientNet(self)
		try:
			self._client_net.connect(addr, port)
			LOG.debug('SMPClient: Connect done')
		except SMPException:
			self._gui.notify_msgbox_signal.emit('Unable to connect to {}:{}'.format(addr, port))
			self._gui.disconnect_signal.emit()

	def disconnect(self, blocking=False):
		# TODO: document
		LOG.debug('SMPClient disconnect()')
		self._client_net.disconnect()
		with self._game_lock:
			self._game_state = None

		# Wait for the network thread to finish
		if blocking and self._client_net.is_alive():
			LOG.info('SMPClient waiting for network thread to finish')
			self._client_net.join()

		self._cid = 0
		self._client_net = None
		self._gui.disconnect_signal.emit()

	def notify_connect(self):
		LOG.debug('SMPClient: notify_connect()')
		self._gui.connect_signal.emit()

	def server_disconnect(self):
		''' Called if the connection has been closed unexpectedly'''
		with self._game_lock:
			self._game_state = None
		self._cid = 0
		self._client_net = None
		self._gui.notify_msgbox_signal.emit('Connection closed unexpectedly')
		self._gui.disconnect_signal.emit()

	def exit(self):
		''' Called by the QApplication event loop '''
		LOG.info('Client exiting.')
		self.stopServerDiscovery()

		# If client is connected, leave game and disconnect
		if self._client_net:
			if self._game_state:
				LOG.info('Leaving game.')
				self._client_net.req_leave_game()

			LOG.info('Disconnecting.')
			self.disconnect(True)

	# Setters / getters

	def set_cid(self, cid):
		LOG.debug('SMPClient: Setting cid={}'.format(cid))
		self._cid = cid

	def set_cname(self, cname):
		if len(cname) >= 255:
			LOG.warn('Given player name is too long, trucated to 255.')
			self._cname = cname[:255]
		self._cname = cname

	######### Network Requests #############

	def create_game(self, max_players):
		if self._client_net:
			self._client_net.req_new_game(max_players)
		else:
			self._gui.show_notification('Not connected to a server.\nCan\'t create a new game.')

	def get_game_list(self):
		if self._client_net:
			self._client_net.req_game_info_list()
			LOG.info('Game list updated')

	def join_game(self, gid):
		self._client_net.req_join_game(gid)
		LOG.info('Joined game {}'.format(gid))

	def leave_game(self):
		self._client_net.req_leave_game()

	def enter_number(self, row, col, value):
		self._client_net.req_enter_number(row, col, value)

	######## Network Notifications ##########

	def notify_game_list_received(self, gilist):
		LOG.debug('SMPClient received GLIST: {}'.format(gilist))
		for pil in [gi['playerinfo'] for gi in gilist]:
			for pi in pil:
				LOG.debug(pi)

		self._gui.game_list_update_signal.emit(gilist)

	def notify_game_joined(self, gid):
		if gid == 0:
			with self._game_lock:
				self._game_state = None
		self._gui.game_join_signal.emit(gid)

	def notify_game_start(self, starttime):
		self._game_state.set_start_time(starttime)
		self._gui.game_start_signal.emit()

	def notify_game_end(self, endtime):
		self._game_state.set_end_time(endtime)
		self._gui.game_end_signal.emit()

	def game_state_update(self, gs_serial):
		LOG.debug('Client: game state update '.format((gs_serial,)))
		with self._game_lock:
			self._game_state = SMPGameState.unserialize(gs_serial)
			self._gui.game_state_signal.emit()

	def game_player_update(self, pi_serial):
		LOG.debug('Client: player update '.format((pi_serial,)))
		if self._game_state:
			with self._game_lock:
				self._game_state.set_serialized_players(pi_serial)
				self._gui.player_update_signal.emit()

	def game_board_update(self, b_serial):
		LOG.debug('Client: board update '.format((b_serial,)))
		if self._game_state:
			with self._game_lock:
				self._game_state.get_puzzle().unserialize_current(b_serial)
				self._gui.board_update_signal.emit()
